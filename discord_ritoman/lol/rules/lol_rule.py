from discord_ritoman.db.accessors import update_lol_user_last_updated
from discord_ritoman.lol.stats.match_stat import get_stat
import enum
from typing import Any, ClassVar, Dict, List, Optional, Union
from discord_ritoman.db.schema import LoLUser


class LoLRuleType(enum.Enum):
    ALL = 0
    GAME_END = 1
    END_OF_DAY = 2
    GAME_START = 3


class LoLRuleData:
    def __init__(
        self,
        obj: ClassVar[Any],
        name: str,
        rule_type: LoLRuleType,
        run_after: List[str],
    ):
        self.name = name
        self.rule_type = rule_type
        self.obj = obj
        self.run_after = run_after


class LoLRule:
    def should_run(
        self, results: Dict[str, bool], user: Union[LoLUser, None] = None
    ) -> bool:
        """"""
        raise NotImplementedError

    def run(
        self, results: Dict[str, bool], user: Union[LoLUser, None] = None
    ) -> None:
        """"""
        raise NotImplementedError


GLOBAL_LOL_RULES: Dict[str, LoLRuleData] = {}


def lol_rule(
    name: str,
    rule_type: LoLRuleType = LoLRuleType.GAME_END,
    run_after: List[str] = [],
) -> Any:
    def decorator(cls: ClassVar[Any]):
        global GLOBAL_LOL_RULES

        # class Wrapper:
        #     def __init__(self, obj: ClassVar[Any]):
        #         self.name = name
        #         self.rule_type = rule_type
        #         self.obj = obj
        #         self.run_after = run_after

        w = LoLRuleData(cls(), name, rule_type, run_after)

        GLOBAL_LOL_RULES[name] = w

        return w

    return decorator


def _get_pending_rules(rule_type: LoLRuleType) -> List[LoLRuleData]:
    """"""
    pending: List[LoLRuleData] = []
    for _, rule in GLOBAL_LOL_RULES.items():
        if rule.rule_type == rule_type or rule_type == LoLRuleType.ALL:
            pending.append(rule)
    return pending


def run_lol_rules(rule_type: LoLRuleType, user: Optional[LoLUser] = None):
    """"""
    pending = _get_pending_rules(rule_type)
    results = {}

    # for _, rule in GLOBAL_LOL_RULES.items():
    #     if rule.rule_type == rule_type or rule_type == LoLRuleType.ALL:
    #         pending.append(rule)

    maxc = len(pending)
    c = 0

    while len(pending) > 0 and c <= maxc:
        c += 1

        rule = pending[0]
        del pending[0]

        can_run = True
        for req in rule.run_after:
            if req not in results:
                can_run = False
                break

        if not can_run:
            pending.append(rule)
            continue

        maxc = len(pending)
        c = 0

        results[rule.name] = rule.obj.should_run(results, user)
        if results[rule.name]:
            rule.obj.run(results, user)

    if c > maxc:
        raise ValueError("Infinite loop generated by rule dependencies")

    # this is built in behavior
    if rule_type == LoLRuleType.ALL or rule_type == LoLRuleType.GAME_END:
        match_end = get_stat("match_end")
        if user is not None:
            if match_end > user.last_updated:
                update_lol_user_last_updated(user, match_end)
